<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RyanKing&#39;s Blog on RyanKing&#39;s Blog</title>
    <link>http://ryanking8215.github.io/</link>
    <description>Recent content in RyanKing&#39;s Blog on RyanKing&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 22 Dec 2019 16:54:09 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>go slice append后的输出问题</title>
      <link>http://ryanking8215.github.io/2019/slice_append_print/</link>
      <pubDate>Sun, 22 Dec 2019 16:54:09 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2019/slice_append_print/</guid>
      <description>

&lt;h1 id=&#34;引子&#34;&gt;引子&lt;/h1&gt;

&lt;p&gt;近日在&lt;a href=&#34;https://juejin.im/entry/5af532836fb9a07ac363847b&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;网上&lt;/a&gt;看到有个go代码，比较有意思，说在第14行注释前和注释后，最后的打印结果是不同的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
)

func main(){
    s := []byte(&amp;quot;&amp;quot;)

    s1 := append(s, &#39;a&#39;)
    s2 := append(s, &#39;b&#39;)

    // 如果释放此行，打印的结果是 a b，否则打印的结果是b b
    //fmt.Println(s1, &amp;quot;===&amp;quot;, s2)
    
    fmt.Println(string(s1), string(s2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;验证一下&#34;&gt;验证一下&lt;/h1&gt;

&lt;p&gt;我用go编译跑了一下，无论是否注释，都是输出&amp;rdquo;a b&amp;rdquo;, 而不是文中提到的&amp;rdquo;b b&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;那么是咋回事呢？我看了下我的go版本是:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go version go1.12.7 linux/amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而文中是go1.9. 幸好我还有go1.10的版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go version go1.10.4 linux/amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看下它的表现，果然结果是不同的，那就可以用go1.10和go1.12做个比较，看下是哪里的不同。&lt;/p&gt;

&lt;p&gt;按照文中所述，输出&amp;rdquo;a b&amp;rdquo;和&amp;rdquo;b b&amp;rdquo;原因是在栈上分配和堆上分配和策略不同所致。
如果14行被注释，那么s将被分配在栈上，而由于是&lt;code&gt;[]byte(&amp;quot;&amp;quot;)&lt;/code&gt;,是将空字符串转成byte slice，在内部执行的是runtime.stringtoslicebyte, 默认分配了32B size的cap；而释放那行，s将逃逸至堆，从堆上分配时，slice的cap为0。由于初始cap不同，造成了结果不同。
至于slice和append的实现，文中说的很明白，这里不赘述了。&lt;/p&gt;

&lt;h1 id=&#34;咋回事&#34;&gt;咋回事&lt;/h1&gt;

&lt;p&gt;我们先来看下旧版的go，为啥注释前后输出不同呢？&lt;/p&gt;

&lt;p&gt;为了更好地说明，我们为其加些调试打印，一窥究竟：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
)

func main(){
    s := []byte(&amp;quot;&amp;quot;)
    println(s) // 调试

    s1 := append(s, &#39;a&#39;)
    println(s1) // 调试
    s2 := append(s, &#39;b&#39;)
    println(s2) // 调试

    // 如果释放此行，打印的结果是 a b，否则打印的结果是b b
    //fmt.Println(s1, &amp;quot;===&amp;quot;, s2)
    
    fmt.Println(string(s1), string(s2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go 1.10&lt;/p&gt;

&lt;h3 id=&#34;注释掉&#34;&gt;注释掉&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;逃逸分析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[legacy@localhost tmp]$ go build -gcflags &#39;-m&#39;
# _/home/legacy/tmp
./main.go:18:23: string(s1) escapes to heap
./main.go:18:23: string(s1) escapes to heap
./main.go:18:35: string(s2) escapes to heap
./main.go:18:35: string(s2) escapes to heap
./main.go:8:16: main ([]byte)(&amp;quot;&amp;quot;) does not escape
./main.go:18:16: main ... argument does not escape
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[0/32]0xc420045f00
[1/32]0xc420045f00
[1/32]0xc420045f00
b b
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，注释那行后，&lt;code&gt;[]byte(&amp;quot;&amp;quot;)&lt;/code&gt;没有逃逸，并且一开始就有了32的cap。之后的append因为有空间，所以仍旧在原slice上操作，b会把a覆盖掉，所以输出&lt;code&gt;b b&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;释放掉&#34;&gt;释放掉&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;逃逸分析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[legacy@localhost tmp]$ go build -gcflags &#39;-m&#39;
# _/home/legacy/tmp
./main.go:17:16: s1 escapes to heap
./main.go:8:16: ([]byte)(&amp;quot;&amp;quot;) escapes to heap
./main.go:17:21: &amp;quot;===&amp;quot; escapes to heap
./main.go:17:21: s2 escapes to heap
./main.go:18:23: string(s1) escapes to heap
./main.go:18:23: string(s1) escapes to heap
./main.go:18:35: string(s2) escapes to heap
./main.go:18:35: string(s2) escapes to heap
./main.go:17:16: main ... argument does not escape
./main.go:18:16: main ... argument does not escape
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[0/0]0x543f18
[1/8]0xc420014068
[1/8]0xc420014080
[97] === [98]
a b
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;释放注释后，&lt;code&gt;[]byte(&amp;quot;&amp;quot;)&lt;/code&gt;逃逸至堆上，并且分配的cap为0的sclie，之后的append均会重新生成一个slice，可以看到s1和s2所代表的slice内部的data地址是不同的，所以打印时，各取各的。&lt;/p&gt;

&lt;p&gt;我们再来看为什么高版本的go1.12，注释以后，还是输出&lt;code&gt;a b&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;go 1.12&lt;/p&gt;

&lt;h3 id=&#34;注释掉-1&#34;&gt;注释掉&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;逃逸分析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[vagrant@localhost 3]$ go build -gcflags &#39;-m&#39;
# escape_analyze/3
./main.go:18:16: inlining call to fmt.Println
/tmp/go-build106864236/b001/_gomod_.go:6:6: can inline init.0
./main.go:18:23: string(s1) escapes to heap
./main.go:18:23: string(s1) escapes to heap
./main.go:18:35: string(s2) escapes to heap
./main.go:18:35: string(s2) escapes to heap
./main.go:18:16: io.Writer(os.Stdout) escapes to heap
./main.go:8:16: main ([]byte)(&amp;quot;&amp;quot;) does not escape
./main.go:18:16: main []interface {} literal does not escape
&amp;lt;autogenerated&amp;gt;:1: os.(*File).close .this does not escape
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[0/0]0xc000034728
[1/8]0xc0000140a8
[1/8]0xc0000140c0
a b
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从逃逸分析上看，&lt;code&gt;[]byte(&amp;quot;&amp;quot;)&lt;/code&gt;是在栈上，但是分配时，不像低版本golang，高版本分配了cap为0的slice，之后的append会创建新的slice，所以输出是&lt;code&gt;a b&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;

&lt;p&gt;不同golang版本的runtime.stringtoslicebyte的实现是不同的，可以查看源码得到。&lt;/p&gt;

&lt;p&gt;实际上&lt;code&gt;s:=[]byte(&amp;quot;&amp;quot;)&lt;/code&gt;这样的写法不是很好，应该是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;s:=[]byte{}
// or
var s []byte
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多的是&lt;code&gt;append&lt;/code&gt;的用法不合理，在同一个slice引用上append多次，结果取决于该slice的cap有多大。
一般写程序会避免这种写法，当然作为研究slice和逃逸分析的例子，还是不错的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Echo v4 的参数绑定问题</title>
      <link>http://ryanking8215.github.io/2019/param_bindings_issue_in_echov4/</link>
      <pubDate>Wed, 13 Nov 2019 14:54:28 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2019/param_bindings_issue_in_echov4/</guid>
      <description>

&lt;h1 id=&#34;现象&#34;&gt;现象&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://echo.labstack.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Echo&lt;/a&gt;是golang语言开发的，高性能, 可扩展的微型web框架。&lt;/p&gt;

&lt;p&gt;笔者在项目中一直使用Echo框架，一直是v3.x的版本，在项目达到一定阶段后，发现Echo已经发布了&amp;rdquo;v4&amp;rdquo;版本一段时间，于是想把框架升级成v4.&lt;/p&gt;

&lt;p&gt;升级之后，发现有些请求出现了问题，具体报错为:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;binding element must be a struct&amp;quot; introduced with path params binding
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;升级后编译一把过，说明API设计的兼容性没有问题，现在是运行时报错了。&lt;/p&gt;

&lt;p&gt;整个demo来验证这个问题, 这个demo是典型的restful应用，url里的参数表示资源id，body传入数据:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
    &amp;quot;github.com/labstack/echo/v4&amp;quot;
    &amp;quot;github.com/labstack/echo/v4/middleware&amp;quot;
    &amp;quot;github.com/labstack/gommon/log&amp;quot;
)

func main() {
    s := echo.New()
    s.Use(middleware.Logger())

    s.PUT(&amp;quot;/users/:id&amp;quot;, func(c echo.Context) error {
        var data interface{}
        if err := c.Bind(&amp;amp;data); err != nil {
            log.Fatal(err)
        }
        log.Print(data)
        return nil
    })

    s.Start(&amp;quot;:8811&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -X PUT -H &amp;quot;Content-Type: application/json&amp;quot; -d &#39;{&amp;quot;name&amp;quot;:&amp;quot;John&amp;quot;}&#39; localhost:8811/users/1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子很简单，有一个URL请求是&lt;code&gt;POST /users/1&lt;/code&gt;, 传入的body是json &lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;John&amp;quot;}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;这个例子造成Echo在调用c.Bind时报错。&lt;/p&gt;

&lt;p&gt;我们看下Echo &lt;code&gt;Bind&lt;/code&gt;的源码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Bind implements the `Binder#Bind` function.
func (b *DefaultBinder) Bind(i interface{}, c Context) (err error) {
        req := c.Request()

        names := c.ParamNames()
        values := c.ParamValues()
        params := map[string][]string{}
        for i, name := range names {
                params[name] = []string{values[i]}
        }
        if err := b.bindData(i, params, &amp;quot;param&amp;quot;); err != nil {
                return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)
        }
        if err = b.bindData(i, c.QueryParams(), &amp;quot;query&amp;quot;); err != nil {
                return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)
        }
        if req.ContentLength == 0 {
                return
        }
        ctype := req.Header.Get(HeaderContentType)
        switch {
        case strings.HasPrefix(ctype, MIMEApplicationJSON):
                if err = json.NewDecoder(req.Body).Decode(i); err != nil {
                        if ute, ok := err.(*json.UnmarshalTypeError); ok {
                                return NewHTTPError(http.StatusBadRequest, fmt.Sprintf(&amp;quot;Unmarshal type error: expected=%v, got=%v, field=%v, offset=%v&amp;quot;, ute.Type, ute.Value, ute.Field, ute.Offset)).SetInternal(err)
                        } else if se, ok := err.(*json.SyntaxError); ok {
                                return NewHTTPError(http.StatusBadRequest, fmt.Sprintf(&amp;quot;Syntax error: offset=%v, error=%v&amp;quot;, se.Offset, se.Error())).SetInternal(err)
                        }
                        return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)
                }    
         ....                     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，它先&lt;code&gt;bindData params&lt;/code&gt;, 而这个&lt;code&gt;param&lt;/code&gt;，即传入的&amp;rdquo;id&amp;rdquo;. 即Echo先尝试绑定param，在&amp;rdquo;ContentLength&amp;gt;0&amp;rdquo;时再绑定body。&lt;/p&gt;

&lt;p&gt;和我们预想的使用&lt;code&gt;c.Bind()&lt;/code&gt;来获取&lt;code&gt;body&lt;/code&gt;数据不符。而查看&amp;rdquo;v3&amp;rdquo;版本的，是没有这个问题的。&lt;/p&gt;

&lt;h1 id=&#34;解决方法&#34;&gt;解决方法&lt;/h1&gt;

&lt;p&gt;可以通过不同方法绕过c.Bind调用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用json.NewDecoder()或者json.Unmarshal()替换c.Bind&lt;/li&gt;
&lt;li&gt;echo支持自定义Binder对象，&lt;code&gt;echo.Binder = MyBinder()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;

&lt;p&gt;笔者把该问题反馈给了上游, 发现有人已经提过&lt;a href=&#34;https://github.com/labstack/echo/issues/1356&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;issue&lt;/a&gt;, 我再补充一下。&lt;/p&gt;

&lt;p&gt;作者之一貌似准备重新release一个版本。&lt;/p&gt;

&lt;p&gt;我提出来是否可以用一个选项来开关该功能(param binding).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PMP相关</title>
      <link>http://ryanking8215.github.io/2019/pmp/</link>
      <pubDate>Mon, 09 Sep 2019 16:48:08 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2019/pmp/</guid>
      <description>

&lt;p&gt;有约2年没写Blog了，时间都是在慵懒中溜走。
今天3月份顺利通过了PMP考试，这里记录一下，报个流水账。&lt;/p&gt;

&lt;h2 id=&#34;出发点&#34;&gt;出发点&lt;/h2&gt;

&lt;p&gt;在公司里我是主管某个产品的研发工作，除了管理团队之外，还要负责服务端架构设计，数据库设计，协议制订，服务端开发(golang)等。&lt;code&gt;Title&lt;/code&gt;是&amp;rdquo;项目经理&amp;rdquo;。
我们的产品就是项目，所以叫&amp;rdquo;项目经理&amp;rdquo;貌似也没问题。那项目经理到底是干什么的，职责是什么，业界是怎么定义项目经理的，这些问题始终困扰着我。&lt;/p&gt;

&lt;p&gt;记得有次项目招标如果有PMP证书能加分， 又听说华为做项目的都需要PMP证书，就对PMP感兴趣起来。&lt;/p&gt;

&lt;p&gt;PMP是Project Management Professional的简称，是由美国项目管理学会(Project Management Institute，PMI）推出，用于评估项目管理人员的知识与技能是否有
高品质需求，被全球公认为项目管理领域的权威认证。&lt;/p&gt;

&lt;h2 id=&#34;报名&#34;&gt;报名&lt;/h2&gt;

&lt;p&gt;去年10月国庆节放假的时候，想到报名。市面上的培训机构挺多，选哪个呢？网上溜达一圈，发现&amp;rdquo;光环国际&amp;rdquo;挺有名的，主要是它靠培训PMP把自己整上市了，WTF。
我也看过其他培训机构的评价，相信也有好的老师，应该也不错，只不过&amp;rdquo;光环&amp;rdquo;太有光环了，保险起见，毕竟培训费加考试费小1万了。&lt;/p&gt;

&lt;p&gt;12月份入学，3月份考试。&lt;/p&gt;

&lt;h2 id=&#34;培训&#34;&gt;培训&lt;/h2&gt;

&lt;p&gt;我记得好像是5天的精讲课，由杨述老师讲述，杨老师来自清华大学，风趣幽默，把项目管理讲得深入浅出，还结合当前时下的高知名度公司和模式，讲述项目管理知识，并且举例说明生动活泼，我们听得欲仙欲死。&lt;/p&gt;

&lt;p&gt;5天时间是都是在周末，期间还过了个年，师傅领进门，修行在个人，平时还是不能忘记听录音，做题的。好久没有做题和考试了，哈哈。&lt;/p&gt;

&lt;h2 id=&#34;微信群和辅导员&#34;&gt;微信群和辅导员&lt;/h2&gt;

&lt;p&gt;微信上有个大群，还邀请前几届的高分学友做辅导员。&lt;/p&gt;

&lt;p&gt;我发现群里能人很多，每天班主任都会发题，谁最快答对有小红花，你别说，人和人之间就是有差距，往往我刚看完题，别人的答案已经出来了，还TMD全对。我去，小红花不奢求了，求过就行。&lt;/p&gt;

&lt;p&gt;另外辅导员也发挥了很大的作用，这里点名表扬姚导，牺牲自己的时间为学员讲解题目，一言不合就飞刀，急人所急。&lt;/p&gt;

&lt;h2 id=&#34;练习题和模拟考试&#34;&gt;练习题和模拟考试&lt;/h2&gt;

&lt;p&gt;要通过考试，不做题是不行的。光环在课后布置了大量的练习题和冲刺题，都需要花时间去做。令人印象深刻的是冲刺题1,2,3, 大概由于翻译关系，读完后中文断句都有问题了。不过也能看到
几周前的错一半，到后面能得到有效提高。&lt;/p&gt;

&lt;p&gt;培训里也包含了3次模拟考，第一次最简单，都是基本知识点；第二次据说最难，但我感觉最好，分数也最低，不知者无畏说的就是这种；第三次不敢造次，正常发挥。&lt;/p&gt;

&lt;h2 id=&#34;考试&#34;&gt;考试&lt;/h2&gt;

&lt;p&gt;考试发生了个插曲，不知怎么搞的，进教室后我的身份证不见了，包里和口袋里找过都没有，最后发现被监考志愿者踩在脚下，难怪找不到了，肯定是趁我吃巧克力时掉了，毕竟考试要4个小时。&lt;/p&gt;

&lt;p&gt;考满4个小时出来的，感觉还可以，有几题还见过，不留遗憾。&lt;/p&gt;

&lt;h2 id=&#34;分数&#34;&gt;分数&lt;/h2&gt;

&lt;p&gt;考完后出分时间一拖再拖，不过该来的总会来，5A通过。&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;考PMP是为了学习项目管理知识，顺便拿个证。光环太牛了，通过率都是在95%左右。&lt;/li&gt;
&lt;li&gt;PMBOK(培训教材)越来越厚, 知识点越来越多，考纲好像也在发生变化，同学们快点走起。&lt;/li&gt;
&lt;li&gt;我有幸也给下一届做了辅&amp;rdquo;捣&amp;rdquo;员，额，捣糨糊的捣。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Test Hugo</title>
      <link>http://ryanking8215.github.io/2019/test_hugo/</link>
      <pubDate>Mon, 19 Aug 2019 18:37:51 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2019/test_hugo/</guid>
      <description>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kk&lt;/th&gt;
&lt;th&gt;jj&lt;/th&gt;
&lt;th&gt;bb&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    fmt.Println(&amp;quot;hello, world&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python3.5 交叉编译</title>
      <link>http://ryanking8215.github.io/2016/python35-cross-compile/</link>
      <pubDate>Sun, 17 Jan 2016 14:50:54 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2016/python35-cross-compile/</guid>
      <description>

&lt;p&gt;有一个嵌入式项目，尝试将python3.5.1移植到该平台。还未确定是否用python开发, 先把
环境整好，到时想用就能用了，也记录一下，可以用这种方法移植到其他平台。&lt;/p&gt;

&lt;h1 id=&#34;问题&#34;&gt;问题&lt;/h1&gt;

&lt;p&gt;Python工程本来就有&lt;code&gt;configure&lt;/code&gt;工具，理论上讲交叉编译比较简单，只要指定&lt;code&gt;--host&lt;/code&gt;为你
的交叉编译工具链即可。其他基于&lt;code&gt;autoconf/automake&lt;/code&gt;的也是类似的。但是Python比较特殊
的是，在交叉编译过程中，会生成&lt;code&gt;Parse/Pgen&lt;/code&gt;和&lt;code&gt;python&lt;/code&gt;应用程序，然后会运行该程序,
那么问题来了，交叉编译出来的程序在开发机上无法执行的，它们是运行在嵌入式系统上的。&lt;/p&gt;

&lt;p&gt;查看网络上的解决方法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为Python工程打补丁&lt;/p&gt;

&lt;p&gt;打补丁的方法只支持到3.2，新版本就没有了, 大意是先是用本地的编译器编译出python和pgen，改名，然后再是用
交叉编译工具编译，当然需要加入特殊的命令行参数来指定刚才编译出来的python和pgen。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;压根不处理&lt;/p&gt;

&lt;p&gt;不处理的也有，就直接make就ok了，是python3.4+mips的环境，不明白怎么没碰到这个问题。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看来要自己解决了。
尝试忽略执行该程序的过程，修改&lt;code&gt;Makefile&lt;/code&gt;, 找到这部分，把它们注释掉，
继续make，最后ok了。
可能不是一个好方法，但是一个可行的方法。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;p&gt;网上找了很多资料做参考，这里记录一下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tuicool.com/articles/b6f6Nvf&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;交叉编译Python至嵌入式arm(支持import sqlite3,datetime等)&amp;mdash;&amp;ndash;Cross Compiling Python for Emb&amp;hellip;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tuicool.com/articles/YRFFfa&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;交叉编译Python 3.3 压成1.5MB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tuicool.com/articles/qe6V3y&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;为 Kindle 交叉编译 Zsh 和 Python 3.3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Django下通过form创建model对象如何隐藏不必要的field</title>
      <link>http://ryanking8215.github.io/2015/django-form-create-model-hidden-field/</link>
      <pubDate>Sun, 25 Oct 2015 10:00:00 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2015/django-form-create-model-hidden-field/</guid>
      <description>

&lt;h1 id=&#34;简述&#34;&gt;简述&lt;/h1&gt;

&lt;p&gt;例如Model A和Model S是一对多的关系，即A是one， S是many, 使用&lt;code&gt;ForeignKey&lt;/code&gt;来定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class A(models.Model):
  name = models.CharFields(max_length=64)

class S(models.Model):
  name = models.CharFields(max_length=64)
  a = models.ForeignKey(A)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在某个页面创建S的时候，需要指定是哪个A。 如果为A和S注册了admin，那么在admin-site里创建S的时候，会看到需要选择哪个A的实例，它会把所有的A的记录都列出来&lt;/p&gt;

&lt;p&gt;但这个是针对admin的，不是针对业务的，如果一个用户想为他名下的某个A资源建立一个S的资源，那么把所有A的记录都列出来是不合适的，也不安全；实际上例如&lt;code&gt;POST /A/1/S/create&lt;/code&gt;这样的url已经含了A的主键，在创建S的时候只需要为a field赋值即可，而且是自动的，不需要用户选择。&lt;/p&gt;

&lt;h1 id=&#34;策略&#34;&gt;策略&lt;/h1&gt;

&lt;p&gt;就是在创建S的时候，不能把a的field暴露出来，并且根据url里的A的主键，将a赋值为A.objects.get(pk=1)即可。&lt;/p&gt;

&lt;h2 id=&#34;方法1&#34;&gt;方法1&lt;/h2&gt;

&lt;p&gt;直接使用&lt;code&gt;CreateView&lt;/code&gt;，model为S，form暴露的fields需要包括&lt;code&gt;a&lt;/code&gt;，在获取form初始值时，将&lt;code&gt;a&lt;/code&gt;赋值。form在render的时候，需要隐藏&lt;code&gt;a field&lt;/code&gt;，需要自定义各form的field，不能使用form.as_p()等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class SCreateView(CreateView):
    model = S
    fields = {&#39;name&#39;,&#39;a&#39;}
    success_url = &#39;myurl&#39;
    template_name = &#39;s_add.html&#39;

    def get(self, request, *args, **kwargs):
        # 这里根据url参数获取A的对象
        self.a_object = A.objects.get(pk=kwargs[&#39;a_id&#39;])

    def get_initial(self):
        # 这里这样默认的form里a field就有值了。
        return {&#39;a&#39;:self.a_object.pk}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;方法2&#34;&gt;方法2&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;SignalObjectMixin&lt;/code&gt;和&lt;code&gt;FormView&lt;/code&gt;的组合，&lt;code&gt;SignalObjectMixin&lt;/code&gt;是为了获取&lt;code&gt;A&lt;/code&gt;的对象，FormView用于处理form的get和post。特别是post，我们的Form不需要有&lt;code&gt;a field&lt;/code&gt;，在form_valid()里，通过&lt;code&gt;form.save(commit=False)&lt;/code&gt;来创建一个S对象，但是该对象还没有持久化，然后为该对象的&lt;code&gt;a field&lt;/code&gt;赋值为self.object.pk(通过SignalObjectMixin)即可，然后调用s.save()即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class SForm(form.ModelForm):
    class Meta:
        model = S
        fields = {&#39;name&#39;}

class SCreateView(SingleObjectMixin, FormView):
    model = A
    form_class = SForm

    def get(self, request, *args, **kwargs):
        self.object = self.get_object()
        return super(SCreateView, self).get(*args, **kwargs)

    def get_context_data(self, **kwargs):
        context = super(SCreateView, self).get_context_data(**kwargs)
        context[&#39;form&#39;] = self.form_class()
        return context

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        return super(SCreateView, self).post(request, *args, **kwargs)

    def form_valid(self, form):
        # commit为False，创建一个未持久化对象
        s = form.save(commit=False)
        # 为s的隐藏field赋值
        s.a = self.object
        # 持久化
        s.save()
        # 后续处理
        return super.form_valid(self, form)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;方法3&#34;&gt;方法3&lt;/h2&gt;

&lt;p&gt;继承&lt;code&gt;CreateView&lt;/code&gt;,重写&lt;code&gt;form_valid()&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from django.views.generic.edit import CreateView
from myapp.models import Author

class SCreate(CreateView):
    model = S
    fields = [&#39;name&#39;]

    def form_valid(self, form):
        # a_object可以从其他地方获取,例如url等获取a的对象，关键是form.instance，因为这个form是ModelForm，为该instance的成员赋值，然后通过super()方法去save即可。
        form.instance.a = self.a_object
        return super(SCreate, self).form_valid(form)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python ctypes</title>
      <link>http://ryanking8215.github.io/2015/python-ctypes/</link>
      <pubDate>Sun, 20 Sep 2015 14:50:54 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2015/python-ctypes/</guid>
      <description>

&lt;p&gt;项目中需要用到python来抓网络包进行分析，看了pip有现成的pcap库，但是没用过，我使用的pcap的接口很简单，所以就想自己封装一个。&lt;/p&gt;

&lt;h1 id=&#34;函数接口通过指针传递数据-如何在python中hold住内存&#34;&gt;函数接口通过指针传递数据，如何在python中hold住内存&lt;/h1&gt;

&lt;p&gt;有接口
    pcap_next_ext(pcap_t *, pcap_pkthdr *, u_char **)&lt;/p&gt;

&lt;p&gt;最后的参数即返回函数内部的内存指针，即该指针指向内部内存，该部分数据即收到的包，在处理协议时，需要对该数据包进行分析:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    u_char * data;
    pcap_next_ext(pcap,&amp;amp;head,&amp;amp;data);
    eth_frame_t *eth = (eth_frame_t *)data;
    rest_data_t * mine = (rest_data_t *)(data+sizeof(*eth))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上是c的调用实例，现在要用python来实现。&lt;/p&gt;

&lt;p&gt;函数声明:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    api.pcap_next_ext.argtypes = (ctypes.c_void_p,pcap_pkther_p, POINTER(POINTER(c_ubyte)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用POINTER(POINTER(c_ubyte))来表示u_char **的类型，为什么不用
&lt;code&gt;POINTER(c_char_p)&lt;/code&gt;呢，因为&lt;code&gt;c_char_p&lt;/code&gt;是以NULL为结束的，所以分析二进制数据的时候，这个是不合适的，因为数据有可能为0,即’\0’,会被截断的。
调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    data = POINTER(c_ubyte)() # u_char *data;
    api.pcap_next_ext(pcap,ctypes.byref(head),ctypes.byref(data))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，data就能hold住c function通过指针返回的数据了。
ctypes.byref(data)即 &amp;amp;data.&lt;/p&gt;

&lt;p&gt;那如何使用data所指向的数据呢?
在python层，它认为是一个pointer, data有contents属性，值是第1个数据，即data[0],当然，我们可以通过data[i]访问索引为i的字节，和c指针一样，但如何强制转换呢？
eth_frame = ctypes.cast(data,eth_frame_p)
那之后的mine指针怎么赋值呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    mine = ctypes.cast(data+eth_frame.size(),rest_data_p)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样是不行的，我们需要得到data的地址，通过ctypes.addressof(data.contents)
这才是data指针的基地址，我们可以通过它来访问后续的内存&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mine = ctypes.cast(ctypes.addressof(data.contents)+eth_frame.size(),rest_data_p)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>资源，认证，鉴权和python的装饰器</title>
      <link>http://ryanking8215.github.io/2015/py-decorate/</link>
      <pubDate>Sun, 12 Apr 2015 16:50:54 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2015/py-decorate/</guid>
      <description>

&lt;h1 id=&#34;简述&#34;&gt;简述&lt;/h1&gt;

&lt;p&gt;这是一个目前在做的flask web项目的一点记录，基本思路是以python的装饰器为request handler加入资源描述，用户认证和鉴权的功能，这样，不用在每个request handler里都把这些代码调用一遍，以装饰器的模式，更加简便和美观，便于调试&lt;/p&gt;

&lt;p&gt;下面描述几个概念&lt;/p&gt;

&lt;h2 id=&#34;资源&#34;&gt;资源&lt;/h2&gt;

&lt;p&gt;这里的资源即人为设定的数据结构，用来描述该request handler会对系统的哪个资源进行什么样的操作。以restful api为例，你需要定义系统中有哪些
资源，该handler是做什么操作(CRUD)。以博客为例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Resource(enum.IntEnum):
    BLOG = 1
    COMMENT = 2

class Operation(enum.IntEnum):
    C = 1&amp;lt;&amp;lt;0
    R = 1&amp;lt;&amp;lt;1
    U = 1&amp;lt;&amp;lt;2
    D = 1&amp;lt;&amp;lt;3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户登录之后，得到资源数据，即BLOG资源可以有哪些操作，COMMENT资源有哪些操作，然后和handler的资源描述一比较，就能得到权限结果。&lt;/p&gt;

&lt;h2 id=&#34;认证和鉴权&#34;&gt;认证和鉴权&lt;/h2&gt;

&lt;p&gt;好多人认为这是一个东西，有些web框架也会认为是一个，但是依本人愚见不是，认证是用户以用户凭证是否能登录进你的系统，而鉴权是用户认证完后得到的权限能做什么操作。
2者有先后的逻辑关系。认证的方法有好多种，目前的系统是通过Digest来认证，简单方便。&lt;/p&gt;

&lt;p&gt;详细说说鉴权，用户登录完后，从系统中取出该用户的权限操作，我这里以dict[Resource] = operation_mask来保存，即权限是一个dict，记录每个资源的操作值。当访问restful api时，
和handler的资源描述比对，其实就是检查dict内是否有对应的资源，通过位操作判断是否有对应的操作权限。简单方便。&lt;/p&gt;

&lt;h2 id=&#34;装饰器&#34;&gt;装饰器&lt;/h2&gt;

&lt;p&gt;有追求的python码农都会考虑通过装饰器来简化函数调用。如果不使用装饰器，代码应该是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_blog():
   set_resource(BLOG,R)
   if not digest_authentication():
       abort(401)
   if not authorization():
       abort(403)
   # 继续处理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果用装饰器，那么应该是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@set_resource(BLOG,R)
@digest_authentication
@authorization
def get_blog():
   # 继续处理
   pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有追求的python码农不会满足于此，每个函数上有3个@,其实本人的项目都是json输出，最后还有@jsonify的装饰器，总共有4个，太多太杂，而且有先后顺序，容易错。
整成一个多好？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@access_config((BLOG,R),is_authentication=True,is_authorization=True)
def get_blog():
    # 继续处理
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有没有点&lt;code&gt;pyramid&lt;/code&gt;的感觉？我们来定义一下access_config这个装饰器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def access_config(resource_authority, is_authentication=True, is_authorization=True):

    &#39;&#39;&#39; 访问设置, 用于简化处理函数的装饰器安装, 装饰器模式
        :param authority: 访问所需的权限值
        :param is_authentication: 是否认证
        :param is_authorization: 是否鉴权,如果is_authentication=False,则该值也无意义
    &#39;&#39;&#39;

    def _deco(func):
        @wraps(func)
        def _deco2(*args,**kwargs):
            f = func
            f = jsonify(f)
            if is_authorization:
                f = authorize(f)
            if is_authentication:
                f = authenticate(f)
            f = access_authority(resource_authority)(f)
            return f(*args,**kwargs)
        return _deco2
    return _deco
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个是要注意调用装饰器的顺序，另外，在&lt;code&gt;access_config&lt;/code&gt;里设置参数，可以为每个handler单独设置是否需要认证和鉴权，便于调试，当然，默认值都是True，调用层参数更少。
大概就是这么个思路，记录一下，希望有帮助。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>pyramid and flask</title>
      <link>http://ryanking8215.github.io/2015/pyramid-and-flask/</link>
      <pubDate>Mon, 06 Apr 2015 16:13:40 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2015/pyramid-and-flask/</guid>
      <description>

&lt;p&gt;有个企业内部项目，restful api，mysql, digest authentication.
python很早就用了，写一些维护的脚本和验证一些算法，简单明了，不用考虑c/c++的内存管理。
但是web开发还是第一次，事先了解了一些python下的web framework&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;web.py&lt;/li&gt;
&lt;li&gt;bottle&lt;/li&gt;
&lt;li&gt;flask&lt;/li&gt;
&lt;li&gt;pyramid&lt;/li&gt;
&lt;li&gt;django&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为ORM使用sqlalchemy，所以先踢掉了django；web.py因为python3和创始人的原因，不再考虑；bottle太过简单，学习可以，用在工程上可能欠妥，也排除；留下了flask和pyramid，flask名气更响，资源更多，但是在简单了解了pyramid后，使用pyramid来开展项目，当然之后由于某些原因又换到了flask，所以把这2个框架的使用和区别做一些记录，以供参考，当然，由于初次接触web框架，难免会有疏漏和错误，望海涵。&lt;/p&gt;

&lt;h2 id=&#34;路由&#34;&gt;路由&lt;/h2&gt;

&lt;p&gt;pyramid把url设置为一个唯一string,然后将hanlder绑定在该string上。几乎所有的配置均可通过装饰器解决，除了url本身，你可以指定method,query strings来绑定具体的handler，不用进一个进口，然后根据query stirng或者method来区分。&lt;/p&gt;

&lt;p&gt;flask使用装饰器直接将url绑定在handler上，无论是使用app还是blueprint。支持继承view的方式来设定handler，我用的最多的就是MethodView。&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;p&gt;pyramid默认模板是mako；flask默认模板是jinjia2。按照jinjia2的说法，两者性能差不多，好像周遭用jinjia2的更多一点。两者均支持更换第三方模板。&lt;/p&gt;

&lt;p&gt;pyramid支持将模板render功能写在装饰器里，而flask需要显式调用&lt;code&gt;render_template()&lt;/code&gt;,我的项目返回json数据，pyramid支持内置的&lt;code&gt;render=&#39;json&#39;&lt;/code&gt;,而flask需要显式调用&lt;code&gt;jsonify&lt;/code&gt;,后来项目换成flask的时候，也如法炮制，将render做成了装饰器。&lt;/p&gt;

&lt;h2 id=&#34;测试&#34;&gt;测试&lt;/h2&gt;

&lt;p&gt;两者的测试哲学不同。&lt;/p&gt;

&lt;p&gt;pyramid因为处理函数返回的数据是dict，所以，它的测试是直接对处理函数测试，将req填好数据，然后直接调用处理函数，得到dict，再验证dict正确性。&lt;/p&gt;

&lt;p&gt;flask需要一个请求上下文来测试，也可以说是模拟一个请求客户端，填入真正的url和数据，返回的也是真的数据，而不是中间数据。&lt;/p&gt;

&lt;p&gt;各有利弊，pyramid的这种方式测不到路由是否正确，flask如果用模板render,得到html，验证数据比较麻烦。&lt;/p&gt;

&lt;h2 id=&#34;python3支持&#34;&gt;python3支持&lt;/h2&gt;

&lt;p&gt;按照各自官网的说法，pyramid对python3完全支持。&lt;/p&gt;

&lt;p&gt;flask本身支持，但是它认为好多add-on仍旧是python2,所以还是推荐python2.&lt;/p&gt;

&lt;h2 id=&#34;更多&#34;&gt;更多&lt;/h2&gt;

&lt;p&gt;pyramid对web还有更多的框架定义，例如&lt;code&gt;security&lt;/code&gt;,支持认证和权限等等。&lt;/p&gt;

&lt;p&gt;flask更内聚一点，额外功能用addon实现。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;两者都是优秀的框架，项目换成flask不是因为flask比pyramid好，只是flask中文资源更多一点，因为初入web,找help更简单一点。
其实，pyramid的config装饰器功能强大，几乎配置均可以写在装饰器里，包括method，query string，render资源，不仅仅是url本身，我喜欢这种方式，似乎其他的web框架都没有这么强大的配置装饰器。
作为初入者，我不太明白为什么flask比pyramid更流行，从最后展现的框架上看，我认为pyramid更好，更符合工程需求，更完善。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用n管理nodejs的版本</title>
      <link>http://ryanking8215.github.io/2014/n-nodejs-version/</link>
      <pubDate>Mon, 10 Nov 2014 21:20:12 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2014/n-nodejs-version/</guid>
      <description>&lt;p&gt;想尝试一下ec6的generator和co,为了不影响原有的开发环境
使用n来管理nodejs的版本。&lt;/p&gt;

&lt;p&gt;n的使用还是很简单的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;n latest
n stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别安装最新发布版本和稳定版本，前者带有ec6支持，后者用于开发环境。
这2个都是安装的二进制版本，不需要编译。&lt;/p&gt;

&lt;p&gt;单独使用&lt;code&gt;n&lt;/code&gt;可以切换版本号，但我的目的是二者共存，&lt;code&gt;n&lt;/code&gt;还有个命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;n use &amp;lt;version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要把这个写个alias到shell里，就能共存啦：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;alias nn=&amp;quot;n use 0.11.14 --harmony&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想尝试generator的，只要&lt;code&gt;nn xxx.js&lt;/code&gt;就好啦！很方便。&lt;/p&gt;

&lt;p&gt;p.s. 之前还用了一小会nvm，是从源码编译node的，在Linux上切换发生了点问题，具体
原因也不查了，it makes no sense. 感觉没&lt;code&gt;n&lt;/code&gt;好用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nodejs的buffer和c string</title>
      <link>http://ryanking8215.github.io/2014/nodejs-buffer-c-string/</link>
      <pubDate>Fri, 31 Oct 2014 19:13:42 +0000</pubDate>
      
      <guid>http://ryanking8215.github.io/2014/nodejs-buffer-c-string/</guid>
      <description>

&lt;p&gt;设备上有现成的二进制通信协议，nodejs作为客户端连接上去发送请求得到响应。
其中有协议是传送字符串，用&lt;code&gt;c struct&lt;/code&gt;表示就是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct Response {
    uint32_t value;
    char name[64];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为c string以&amp;rsquo;\0&amp;rsquo;为结束，为了协议到c的对端能开箱即用，name最多存63个字节。&lt;/p&gt;

&lt;p&gt;node客户端收到数据后，用buffer来处理，转换成response对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
    value: {number}
    name: {string}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;buf转string的函数是 &lt;code&gt;buf.toString()&lt;/code&gt;，但是得到的数据类似于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\u0000&#39;,&#39;\u0000&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为js的string不是以&amp;rsquo;\0&amp;rsquo;结束，它把后面的都处理为字符串的一部分，所以我们要处理一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;name = name.substring(0,name.indexOf(&#39;\u0000&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就ok了&lt;/p&gt;

&lt;h3 id=&#34;编码问题&#34;&gt;编码问题&lt;/h3&gt;

&lt;p&gt;默认的hex和utf8,nodejs的buffer api都能处理，但是如果是其他编码呢？比如由于历史原因，设备上
传输的中文编码是gb2312。
很幸运的是，npm里有iconv-lite的package，它能将不同的编码从string-&amp;gt;buffer, buffer-&amp;gt;string的转换。
用它就能开心的撸了！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何使用nodejs撸一个tcp client</title>
      <link>http://ryanking8215.github.io/2014/nodejs-tcp-client/</link>
      <pubDate>Tue, 28 Oct 2014 22:20:00 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2014/nodejs-tcp-client/</guid>
      <description>&lt;p&gt;单看话题有点low,用nodejs撸一个tcp client不是秒秒钟的事情
封装一个client，sock收到data后解析出msg，通过event通知调用端msg来了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var sock = net.createConnection(...);
sock.on(&#39;error&#39;,function(){
	
})
sock.on(&#39;data&#39;,function(buf){
	var msg = parse_data(buf)
	self.emit(&#39;msg&#39;,msg)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大意如此，不要在意细节。如果真是这样的话，那就没有必要撸这个博文了。&lt;/p&gt;

&lt;p&gt;首先要看封装的api到什么程度，client.sendRequest()之后如果什么都不干，光等msg过来，对于
调用你client库的主来说真的是苦主了，一般client都有业务逻辑在，例如先connect(),再login(),
然后再干嘛干嘛；也需要判断response，你都放在&lt;code&gt;client.on(&#39;msg&#39;,function(){...})&lt;/code&gt;里，让别人情何以堪。&lt;/p&gt;

&lt;p&gt;那应该怎么做呢？&lt;/p&gt;

&lt;h3 id=&#34;api设计&#34;&gt;API设计&lt;/h3&gt;

&lt;p&gt;我们让client api好用一点，一般是这样子的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;client.sendRequest(msg,function(err,result){})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者这样子的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;client.sendRequest(msg) -&amp;gt; Promise(result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前者通过回调函数返回错误或结果，后者通过Promise返回，本质是一样的。
因为server消息需要异步处理，所以我们需要callback或者promise来返回结果。&lt;/p&gt;

&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;

&lt;p&gt;api的方式确定下来了，那么要研究如何实现了，假设用callback方式吧，这也是目前nodejs的api的标准格式。
server的数据是通过socket的&lt;code&gt;data&lt;/code&gt;事件来的，client.sendRequest(msg,cb)函数里，会有cb这个参数，如何把它们联系起来呢？
只要收到消息之后执行cb()，就可以通知调用端了。回复消息的处理在另一个函数上下文里，如果能把cb搬过去，在那个函数上下文执行就好了。
可以利用队列，当sendRequest()时，构建一个内部使用的request对象，将cb和请求参数塞入队列，
在&lt;code&gt;data&lt;/code&gt;的事件处理中，从队列依次取出request对象，比对请求参数和回复消息，然后可以执行cb()函数了，这样调用端就会得到结果了。&lt;/p&gt;

&lt;p&gt;用promise也是一样的，用defer代替cb，ok的就defer.resolve(result); 出现错误了就defer.reject(err)。
了解promise的都知道我在说什么，^_^&lt;/p&gt;

&lt;h3 id=&#34;buffer处理&#34;&gt;buffer处理&lt;/h3&gt;

&lt;p&gt;tcp是流式的，没有消息边界，换言之，&lt;code&gt;data&lt;/code&gt;事件回调里的buffer，不一定含有一条或者多条完整的协议消息，有可能是不完整的，有可能是多条完整加一点不完整的，
总之不能做假设任何，这是tcp的粘包问题，这也是为什么tcp协议都会设定同步头，数据长度或者数据分隔符的原因。
在收到data之后，需要和client的缓存拼接起来，看是否能parse出消息，如果能的，则需要把处理过的buffer都去除，
未处理的buffer留下来的，以待后用。
那如何维护这个缓存呢？看一下的demo&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
Session.prototype.append = function(buf) {
    if (!buf)
        return

    if (!this._buf) {
        this._buf = buf
        this._buf_len = buf.length
        return
    }

    var left = this._buf.length - this._buf_len
    if (left&amp;gt;=buf.length) {
        buf.copy(this._buf,this._buf_len)
        this._buf_len+=buf.length
        return
    }
    this._buf = Buffer.concat([this._buf.slice(0,this._buf_len),buf])
    this._buf_len+=buf.length
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是维护一个_buf和_buf_len，前者表示缓存，后者表示数据大小，不是缓存容量大小。遵循以下规则:
- 如果没有，则新建。
- 如果buffer剩余空间比当前buffer大，则把当前buffer的数据copy进缓存
- 如果buffer剩余空间比当前buffer小，则将来缓存数据和buffer数据合并，作为新的缓存。&lt;/p&gt;

&lt;p&gt;消息处理只要用到内部缓存就可以了。
这样在一定程度上避免了频繁申请内存。
但是频繁申请内存还是逃避不了，因为libuv在底层会一直接受数据，否则你以为回调函数里的buffer是哪里来的
这个和reactor模式不同，nodejs可以通过sock.pause(),sock.resume()控制接收速度，让内存不要增加太快。&lt;/p&gt;

&lt;p&gt;另外由于v8对gc不那么积极，而且buffer的内存在v8的heap外，这样buffer会释放的更慢。
开源项目&lt;a href=&#34;https://github.com/clowwindy/shadowsocks-nodejs&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;shadowsock-nodejs&lt;/a&gt;，作者之前因为内存暴涨问题，放弃了该版本。
不清楚nodejs对内存暴涨如何解决。本来nodejs最擅长的就是干这个事情，结果因为这个原因，反而不合适，是比较遗憾的。&lt;/p&gt;

&lt;p&gt;欢迎大家探讨！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用户认证加密方法</title>
      <link>http://ryanking8215.github.io/2014/user-encrpto/</link>
      <pubDate>Sun, 05 Oct 2014 17:20:36 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2014/user-encrpto/</guid>
      <description>

&lt;h2 id=&#34;简单方法&#34;&gt;简单方法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    sha256(sha256(passwd) + passwd_salt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;passwd_salt 是一个随机生成的 sha256 值。
salt和key都要存储&lt;/p&gt;

&lt;h2 id=&#34;标准方法&#34;&gt;标准方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/PBKDF2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;PBKDF2&lt;/a&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Bcrypt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;BCRYPT&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git远程的仓库和分支操作</title>
      <link>http://ryanking8215.github.io/2014/git-remote/</link>
      <pubDate>Sun, 05 Oct 2014 17:00:20 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2014/git-remote/</guid>
      <description>&lt;p&gt;看了git的手册，关于remote的操作。稍微精简了一下，以供记录和记忆。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看远程仓库
    git remote [-v]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加远程仓库
    git remote add [remote-name] [url]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;改名远程仓库
    git remote rename [old-name] [new-name]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除远程仓库
    git remote rm [remote-name]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;抓取远程仓库的数据
    git fetch [remote-name]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;推送数据到远程分支
    git push [remote-name] [branch-name]
    git push [remote-name] [local-branch-name]:[remote-branch-name]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除远程仓库分支
    git push [remote-name] :[remote-branch-name]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用本地分支跟踪远程分支
    git checkout &amp;ndash;track [remote-name]/[remote-branch-name]
    git checout -b [local-branch-name] [remote-name]/[remote-branch-name]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果本地分支为跟踪分支：
在此分支下 git pull（fetch and merge）, git push可以自动识别远程信息，不需要填写remote-name/branch-name了。包括git clone来分支的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;合并本地分支和远程分支
    git merge [remote-name]/[remote-branch-name]&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>promise要注意的地方</title>
      <link>http://ryanking8215.github.io/2014/promise-careful/</link>
      <pubDate>Sun, 05 Oct 2014 16:50:54 +0800</pubDate>
      
      <guid>http://ryanking8215.github.io/2014/promise-careful/</guid>
      <description>&lt;p&gt;promise可以级联，但是不要忘记在then()中return一个Promise,否则将会并发执行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;do_a()
.then(function(){
      do_b()
})
.then(function(){
     do_c()
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;VS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;do_a()
.then(function(){
      return do_b()
})
.then(function(){
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;切记！&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>